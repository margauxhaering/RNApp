write.table(test_data,file=tmp, sep='\t', quote = F, col.names=NA)
#read it back in as an expression set
data <- table2eset(file=tmp)
test_data
write.table(test_data,file=tmp, sep='\t', col.names=NA)
#read it back in as an expression set
data <- table2eset(file=tmp)
data.s <- standardise(data)
m1 <- mestimate(data.s)
clust=k
i=0
for (i in 0:9){
N_cl<- mfuzz(data.s, c=clust, m = m1)
i = i + 1
}
#observe the size of the clusters
N_cl$size
#take a look to the overlap of clusters (if no overlap even with low threshold or membership value it means they cluster well)
ov <- overlap(N_cl)
Ptmp<- overlap.plot(N_cl,over=ov, thres=0.3)
Ptmp<- overlap.plot(N_cl,over=ov, thres=0.3)
#take a look to the overlap of clusters (if no overlap even with low threshold or membership value it means they cluster well)
ov <- overlap(N_cl)
Ptmp<- overlap.plot(N_cl,over=ov, thres=0.3)
for (i in 0:9){
N_cl<- mfuzz(data.s, c=clust, m = m1)
i = i + 1
}
#take a look to the overlap of clusters (if no overlap even with low threshold or membership value it means they cluster well)
ov <- overlap(N_cl)
Ptmp<- overlap.plot(N_cl,over=ov, thres=0.3)
counts <- as.data.frame(read.delim("~/Desktop/data_mean.csv", header = T, sep = '\t'))
row.names(counts) <- counts[,1]
counts <- counts[,-1]
counts <- counts[rowSums(counts >= 1) > 0 , ]
hierdata <- as.matrix((counts))
# Euclidean distance
dist <- dist(hierdata, diag=TRUE)
# Hierarchical Clustering with hclust
hc <- hclust(dist)
# Plot the result
plot(hc,xlab=NULL, labels = FALSE)
#aide au choix du nb de clusters
inertie <- sort(hc$height, decreasing = TRUE)
plot(inertie[1:40], type = "s", xlab = "Nombre de classes", ylab = "Inertie",lwd=2);grid()
plot(inertie[1:30], type = "s", xlab = "Nombre de classes", ylab = "Inertie",lwd=2);grid()
k <- 20
abline(v=k,col="red",lty=3)
points(k,inertie[k],pch=16,cex=2,col="red")
y <- as.matrix((counts))
y <- DGEList(counts = y, group=colnames(counts))
y <- calcNormFactors(y)
z <- cpm(y, normalized.lib.size=TRUE)
library(Mfuzz)
#first get the time point data together:
timepoint <- colnames(counts)
# bind that to the dataframe
test_data <- rbind(timepoint, z)
row.names(test_data)[1]<-"time"
#save it to a temp file so it doesnt clutter up my blog directory
tmp <- tempfile()
write.table(test_data,file=tmp, sep='\t', col.names=NA)
#read it back in as an expression set
data <- table2eset(file=tmp)
data.s <- standardise(data)
m1 <- mestimate(data.s)
clust=k
i=0
for (i in 0:9){
N_cl<- mfuzz(data.s, c=clust, m = m1)
i = i + 1
}
#observe the size of the clusters
N_cl$size
#take a look to the overlap of clusters (if no overlap even with low threshold or membership value it means they cluster well)
ov <- overlap(N_cl)
Ptmp<- overlap.plot(N_cl,over=ov, thres=0.3)
mfuzz.plot(data.s,cl=N_cl,mfrow=c(1,1),time.labels=c("eL3.6h","eL3.15h","eL3.25h","WL3"),new.window=F)
mfuzz.plot(data.s,cl=N_cl,mfrow=c(5,4),time.labels=c("eL3.6h","eL3.15h","eL3.25h","WL3"),new.window=F)
shiny::runApp('Desktop/RNApp/App')
counts <- as.data.frame(read.delim("~/Desktop/data_mean.csv", header = T, sep = '\t'))
row.names(counts) <- counts[,1]
counts <- counts[,-1]
counts <- counts[rowSums(counts >= 1) > 0 , ]
hierdata <- as.matrix((counts))
# Euclidean distance
dist <- dist(hierdata, diag=TRUE)
# Hierarchical Clustering with hclust
hc <- hclust(dist)
# Plot the result
plot(hc,xlab=NULL, labels = FALSE)
#aide au choix du nb de clusters
inertie <- sort(hc$height, decreasing = TRUE)
plot(inertie[1:30], type = "s", xlab = "Nombre de classes", ylab = "Inertie",lwd=2);grid()
plot(inertie[1:30], type = "s", xlab = "Nombre de classes", ylab = "Inertie",lwd=2);grid()
k <- 19
abline(v=k,col="red",lty=3)
points(k,inertie[k],pch=16,cex=2,col="red")
y <- as.matrix((counts))
y <- DGEList(counts = y, group=colnames(counts))
y <- calcNormFactors(y)
z <- cpm(y, normalized.lib.size=TRUE)
library(Mfuzz)
#first get the time point data together:
timepoint <- colnames(counts)
# bind that to the dataframe
test_data <- rbind(timepoint, z)
row.names(test_data)[1]<-"time"
#save it to a temp file so it doesnt clutter up my blog directory
tmp <- tempfile()
write.table(test_data,file=tmp, sep='\t', col.names=NA)
#read it back in as an expression set
data <- table2eset(file=tmp)
data.s <- standardise(data)
m1 <- mestimate(data.s)
clust=k
i=0
for (i in 0:9){
N_cl<- mfuzz(data.s, c=clust, m = m1)
i = i + 1
}
#observe the size of the clusters
N_cl$size
#take a look to the overlap of clusters (if no overlap even with low threshold or membership value it means they cluster well)
ov <- overlap(N_cl)
Ptmp<- overlap.plot(N_cl,over=ov, thres=0.3)
mfuzz.plot(data.s,cl=N_cl,mfrow=c(1,1),time.labels=c("eL3.6h","eL3.15h","eL3.25h","WL3"),new.window=F)
#here you'll find the clusters
acore <- acore(data.s,N_cl, min.acore = 0)
write.table(acore[1],"~/Desktop/RNASEQ/cluster1.txt", sep = "\t")
write.table(acore[2],"~/Desktop/RNASEQ/cluster2.txt", sep = "\t")
write.table(acore[3],"~/Desktop/RNASEQ/cluster3.txt", sep = "\t")
write.table(acore[4],"~/Desktop/RNASEQ/cluster4.txt", sep = "\t")
write.table(acore[5],"~/Desktop/RNASEQ/cluster5.txt", sep = "\t")
write.table(acore[6],"~/Desktop/RNASEQ/cluster6.txt", sep = "\t")
write.table(acore[7],"~/Desktop/RNASEQ/cluster7.txt", sep = "\t")
write.table(acore[8],"~/Desktop/RNASEQ/cluster8.txt", sep = "\t")
write.table(acore[9],"~/Desktop/RNASEQ/cluster9.txt", sep = "\t")
write.table(acore[10],"~/Desktop/RNASEQ/cluster10.txt", sep = "\t")
write.table(acore[11],"~/Desktop/RNASEQ/cluster11.txt", sep = "\t")
write.table(acore[12],"~/Desktop/RNASEQ/cluster12.txt", sep = "\t")
write.table(acore[13],"~/Desktop/RNASEQ/cluster13.txt", sep = "\t")
write.table(acore[14],"~/Desktop/RNASEQ/cluster14.txt", sep = "\t")
write.table(acore[15],"~/Desktop/RNASEQ/cluster15.txt", sep = "\t")
write.table(acore[16],"~/Desktop/RNASEQ/cluster16.txt", sep = "\t")
write.table(acore[17],"~/Desktop/RNASEQ/cluster17.txt", sep = "\t")
write.table(acore[18],"~/Desktop/RNASEQ/cluster18.txt", sep = "\t")
write.table(acore[19],"~/Desktop/RNASEQ/cluster19.txt", sep = "\t")
counts <- as.data.frame(read.delim("~/Desktop/MACS2 counts - 15h - 25h - WL3 - qscore sup 4.csv", header = T, sep = '\t'))
counts
counts <- as.data.frame(read.delim("~/Desktop/MACS2 counts - 15h - 25h - WL3 - qscore sup 4.csv", header = T, sep = ';'))
counts
row.names(counts) <- counts[,1]
counts <- counts[,-1]
counts <- counts[rowSums(counts >= 1) > 0 , ]
hierdata <- as.matrix((counts))
# Euclidean distance
dist <- dist(hierdata, diag=TRUE)
# Hierarchical Clustering with hclust
hc <- hclust(dist)
# Plot the result
plot(hc,xlab=NULL, labels = FALSE)
#aide au choix du nb de clusters
inertie <- sort(hc$height, decreasing = TRUE)
plot(inertie[1:30], type = "s", xlab = "Nombre de classes", ylab = "Inertie",lwd=2);grid()
k <- 25
abline(v=k,col="red",lty=3)
points(k,inertie[k],pch=16,cex=2,col="red")
y <- as.matrix((counts))
y <- DGEList(counts = y, group=colnames(counts))
y <- calcNormFactors(y)
z <- cpm(y, normalized.lib.size=TRUE)
library(Mfuzz)
#first get the time point data together:
timepoint <- colnames(counts)
# bind that to the dataframe
test_data <- rbind(timepoint, z)
row.names(test_data)[1]<-"time"
#save it to a temp file so it doesnt clutter up my blog directory
tmp <- tempfile()
write.table(test_data,file=tmp, sep='\t', col.names=NA)
#read it back in as an expression set
data <- table2eset(file=tmp)
data.s <- standardise(data)
m1 <- mestimate(data.s)
clust=k
i=0
for (i in 0:9){
N_cl<- mfuzz(data.s, c=clust, m = m1)
i = i + 1
}
#observe the size of the clusters
N_cl$size
#take a look to the overlap of clusters (if no overlap even with low threshold or membership value it means they cluster well)
ov <- overlap(N_cl)
Ptmp<- overlap.plot(N_cl,over=ov, thres=0.3)
counts <- as.data.frame(read.delim("~/Desktop/MACS2 counts - 15h - 25h - WL3 - qscore sup 4.csv", header = T, sep = ';'))
row.names(counts) <- counts[,1]
counts <- counts[,-1]
counts <- counts[rowSums(counts >= 1) > 0 , ]
hierdata <- as.matrix((counts))
# Euclidean distance
dist <- dist(hierdata, diag=TRUE)
# Hierarchical Clustering with hclust
hc <- hclust(dist)
# Plot the result
plot(hc,xlab=NULL, labels = FALSE)
#aide au choix du nb de clusters
inertie <- sort(hc$height, decreasing = TRUE)
plot(inertie[1:30], type = "s", xlab = "Nombre de classes", ylab = "Inertie",lwd=2);grid()
k <- 19
abline(v=k,col="red",lty=3)
points(k,inertie[k],pch=16,cex=2,col="red")
y <- as.matrix((counts))
y <- DGEList(counts = y, group=colnames(counts))
y <- calcNormFactors(y)
z <- cpm(y, normalized.lib.size=TRUE)
library(Mfuzz)
#first get the time point data together:
timepoint <- colnames(counts)
# bind that to the dataframe
test_data <- rbind(timepoint, z)
row.names(test_data)[1]<-"time"
#save it to a temp file so it doesnt clutter up my blog directory
tmp <- tempfile()
write.table(test_data,file=tmp, sep='\t', col.names=NA)
#read it back in as an expression set
data <- table2eset(file=tmp)
data.s <- standardise(data)
m1 <- mestimate(data.s)
counts <- as.data.frame(read.csv("~/Desktop/ATAC_mean.csv", header = T, sep = '\t'))
counts
row.names(counts) <- counts[,1]
counts <- counts[,-1]
counts <- counts[rowSums(counts >= 1) > 0 , ]
hierdata <- as.matrix((counts))
# Euclidean distance
dist <- dist(hierdata, diag=TRUE)
# Hierarchical Clustering with hclust
hc <- hclust(dist)
# Plot the result
plot(hc,xlab=NULL, labels = FALSE)
#aide au choix du nb de clusters
inertie <- sort(hc$height, decreasing = TRUE)
plot(inertie[1:30], type = "s", xlab = "Nombre de classes", ylab = "Inertie",lwd=2);grid()
k <- 22
abline(v=k,col="red",lty=3)
points(k,inertie[k],pch=16,cex=2,col="red")
y <- as.matrix((counts))
y <- DGEList(counts = y, group=colnames(counts))
y <- calcNormFactors(y)
z <- cpm(y, normalized.lib.size=TRUE)
library(Mfuzz)
#first get the time point data together:
timepoint <- colnames(counts)
# bind that to the dataframe
test_data <- rbind(timepoint, z)
row.names(test_data)[1]<-"time"
#save it to a temp file so it doesnt clutter up my blog directory
tmp <- tempfile()
write.table(test_data,file=tmp, sep='\t', col.names=NA)
#read it back in as an expression set
data <- table2eset(file=tmp)
data.s <- standardise(data)
m1 <- mestimate(data.s)
clust=k
i=0
for (i in 0:9){
N_cl<- mfuzz(data.s, c=clust, m = m1)
i = i + 1
}
#observe the size of the clusters
N_cl$size
#take a look to the overlap of clusters (if no overlap even with low threshold or membership value it means they cluster well)
ov <- overlap(N_cl)
Ptmp<- overlap.plot(N_cl,over=ov, thres=0.3)
counts <- as.data.frame(read.csv("~/Desktop/ATAC_mean.csv", header = T, sep = '\t'))
row.names(counts) <- counts[,1]
counts <- counts[,-1]
counts <- counts[rowSums(counts >= 1) > 0 , ]
hierdata <- as.matrix((counts))
# Euclidean distance
dist <- dist(hierdata, diag=TRUE)
# Hierarchical Clustering with hclust
hc <- hclust(dist)
# Plot the result
plot(hc,xlab=NULL, labels = FALSE)
#aide au choix du nb de clusters
inertie <- sort(hc$height, decreasing = TRUE)
plot(inertie[1:30], type = "s", xlab = "Nombre de classes", ylab = "Inertie",lwd=2);grid()
k <- 17
abline(v=k,col="red",lty=3)
points(k,inertie[k],pch=16,cex=2,col="red")
y <- as.matrix((counts))
y <- DGEList(counts = y, group=colnames(counts))
y <- calcNormFactors(y)
z <- cpm(y, normalized.lib.size=TRUE)
library(Mfuzz)
#first get the time point data together:
timepoint <- colnames(counts)
# bind that to the dataframe
test_data <- rbind(timepoint, z)
row.names(test_data)[1]<-"time"
#save it to a temp file so it doesnt clutter up my blog directory
tmp <- tempfile()
write.table(test_data,file=tmp, sep='\t', col.names=NA)
#read it back in as an expression set
data <- table2eset(file=tmp)
data.s <- standardise(data)
m1 <- mestimate(data.s)
clust=k
i=0
for (i in 0:9){
N_cl<- mfuzz(data.s, c=clust, m = m1)
i = i + 1
}
#observe the size of the clusters
N_cl$size
#take a look to the overlap of clusters (if no overlap even with low threshold or membership value it means they cluster well)
ov <- overlap(N_cl)
Ptmp<- overlap.plot(N_cl,over=ov, thres=0.3)
mfuzz.plot(data.s,cl=N_cl,mfrow=c(1,1),time.labels=c("eL3.15h","eL3.25h","WL3"),new.window=F)
plots.dir.path <- list.files(tempdir(), pattern="rs-graphics", full.names = TRUE);
plots.png.paths <- list.files(plots.dir.path, pattern=".png", full.names = TRUE)
file.copy(from=plots.png.paths, to="~/Desktop/Mfuzz")
plots.dir.path <- list.files(tempdir(), pattern="rs-graphics", full.names = TRUE);
plots.png.paths <- list.files(plots.dir.path, pattern=".png", full.names = TRUE)
file.copy(from=plots.png.paths, to="~/Desktop/Mfuzz")
#here you'll find the clusters
acore <- acore(data.s,N_cl, min.acore = 0)
write.table(acore[1],"~/Desktop/Mfuzz/cluster1.txt", sep = "\t")
write.table(acore[2],"~/Desktop/Mfuzz/cluster2.txt", sep = "\t")
write.table(acore[3],"~/Desktop/Mfuzz/cluster3.txt", sep = "\t")
write.table(acore[4],"~/Desktop/Mfuzz/cluster4.txt", sep = "\t")
write.table(acore[5],"~/Desktop/Mfuzz/cluster5.txt", sep = "\t")
write.table(acore[6],"~/Desktop/Mfuzz/cluster6.txt", sep = "\t")
write.table(acore[7],"~/Desktop/Mfuzz/cluster7.txt", sep = "\t")
write.table(acore[8],"~/Desktop/Mfuzz/cluster8.txt", sep = "\t")
write.table(acore[9],"~/Desktop/Mfuzz/cluster9.txt", sep = "\t")
write.table(acore[10],"~/Desktop/Mfuzz/cluster10.txt", sep = "\t")
write.table(acore[11],"~/Desktop/Mfuzz/cluster11.txt", sep = "\t")
write.table(acore[12],"~/Desktop/Mfuzz/cluster12.txt", sep = "\t")
write.table(acore[13],"~/Desktop/Mfuzz/cluster13.txt", sep = "\t")
write.table(acore[14],"~/Desktop/Mfuzz/cluster14.txt", sep = "\t")
write.table(acore[15],"~/Desktop/Mfuzz/cluster15.txt", sep = "\t")
write.table(acore[16],"~/Desktop/Mfuzz/cluster16.txt", sep = "\t")
write.table(acore[17],"~/Desktop/Mfuzz/cluster17.txt", sep = "\t")
counts <- as.data.frame(read.csv("~/Desktop/data/D1mRNA.csv", header = T, sep = '\t'))
counts <- as.data.frame(read.csv("~/Desktop/data/D1miRNA.csv", header = T, sep = '\t'))
row.names(counts) <- counts[,1]
counts <- counts[,-1]
counts <- counts[rowSums(counts >= 1) > 0 , ]
hierdata <- as.matrix((counts))
# Euclidean distance
dist <- dist(hierdata, diag=TRUE)
# Hierarchical Clustering with hclust
hc <- hclust(dist)
# Plot the result
#plot(hc,xlab=NULL, labels = FALSE)
#aide au choix du nb de clusters
inertie <- sort(hc$height, decreasing = TRUE)
plot(inertie[1:30], type = "s", xlab = "Nombre de classes", ylab = "Inertie",lwd=2);grid()
k <- 17
abline(v=k,col="red",lty=3)
points(k,inertie[k],pch=16,cex=2,col="red")
k <- 5
abline(v=k,col="red",lty=3)
points(k,inertie[k],pch=16,cex=2,col="red")
y <- as.matrix((counts))
y <- DGEList(counts = y, group=colnames(counts))
y <- calcNormFactors(y)
z <- cpm(y, normalized.lib.size=TRUE)
library(Mfuzz)
#first get the time point data together:
timepoint <- colnames(counts)
# bind that to the dataframe
test_data <- rbind(timepoint, z)
row.names(test_data)[1]<-"time"
#save it to a temp file so it doesnt clutter up my blog directory
tmp <- tempfile()
write.table(test_data,file=tmp, sep='\t', col.names=NA)
#read it back in as an expression set
data <- table2eset(file=tmp)
data.s <- standardise(data)
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
?mfuzz.plot
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
?zip
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
Mfuzzgui()
data(cars);
X= cars$speed;
Y=cars$dist;
plot(X, Y, main="Distance de freinage en fonction de la vitesse du vehicule", ylab="distance en pieds", xlab="vitesse  (miles/h)", pch=3, col="red")
data(cars);
X= cars$speed;
Y=cars$dist;
plot(X, Y, main="Distance de freinage en fonction de la vitesse du vehicule", ylab="distance en pieds", xlab="vitesse  (miles/h)", pch=3, col="red")
#Vectuer X
Moy=function(x){sum(x)/(length(x))}
Moy_X= Moy(X) ; Moy_X
mean(X) ;
Var_X=(1/length(X))*sum((X-(Moy_X))^2) ;
Ecart.type_X =sqrt(Var_X) ; Ecart.type_X
sd(X) ;
#Vectuer Y
Moy_Y=sum(Y)/length(Y) ; Moy_Y
mean(Y)
Var_Y=(1/length(Y))*sum((Y-(Moy_Y))^2) ;
Ecart.type_Y =sqrt(Var_Y) ; Ecart.type_Y
sd(Y)
Cov_X.Y= Moy((X-Moy(X))*(Y-Moy(Y))) ; Cov_X.Y
cov(X,Y)
plot(X, Y, main="Distance de freinage en fonction de la vitesse du vehicule", ylab="distance en pieds", xlab="vitesse  (miles/h)", col="red", pch=3)
l=lm(formula = Y ~ X);
abline(l)
res.reg=lm(Y~X) ; res.reg
a=l$coefficients[2]
b=l$coefficients[1]
e=Y-(b+a*X);
SSR=sum(e^2);SSR
plot(X, Y, main="Distance de freinage en fonction de la vitesse du vehicule", ylab="distance", xlab="vitesse (miles/h)", col="red", pch=3)
abline(l)
Y_pred= b+a*X
segments(X,Y,X, Y_pred,col="blue")
R2=(Var_Y-SSR/length(Y))/Var_Y ; R2
summary(l)
hist(e, main="histogramme des residus",col="pink", freq=FALSE)
curve(dnorm(x,mean(e), sd(e)), col="blue", add=TRUE)
boxplot(e, main="boite a moustahce des residus",col="yellow")
qqnorm(e, main="Diagramme QQ des residus",col="red")
qqline(e)
##install.packages("nortest")
##library(nortest)
##ad.test(e)
##install.packages("nortest")
##library(nortest)
##ad.test(e)
plot(X, Y, main="Distance de freinage en fonction de la vitesse du vehicule", ylab="distance en pieds", xlab="vitesse  (miles/h)", col="red", pch=3)
l2=lm(Y~log(X));
abline(l2)
summary(lm(Y~log(X)))$r.squared
plot(X, Y, main="Distance de freinage en fonction de la vitesse du vehicule", ylab="distance en pieds", xlab="vitesse  (miles/h)", col="red", pch=3)
l3=lm(log(Y)~X);
abline(l3)
summary(lm(log(Y)~X))$r.squared
plot(X, Y, main="Distance de freinage en fonction de la vitesse du vehicule", ylab="distance en pieds", xlab="vitesse  (miles/h)", col="red", pch=3)
l4=lm(Y~X^2);
abline(l4)
summary(lm(Y~X^2))$r.squared
plot(X, Y, main="Distance de freinage en fonction de la vitesse du vehicule", ylab="distance en pieds", xlab="vitesse  (miles/h)", col="red", pch=3)
l5=lm((Y)^2~X);
abline(l5)
summary(lm(Y^2~X))$r.squared
plot(X, Y, main="Distance de freinage en fonction de la vitesse du vehicule", ylab="distance en pieds", xlab="vitesse  (miles/h)", col="red", pch=3)
l6=lm(Y~sqrt(X));
abline(l6)
summary(lm (Y~sqrt(X)))$r.squared
plot(X, Y, main="Distance de freinage en fonction de la vitesse du vehicule", ylab="distance en pieds", xlab="vitesse  (miles/h)", col="red", pch=3)
l7=lm(sqrt(Y)~X);
abline(l7)
summary(lm(sqrt(Y)~X))$r.squared
plot(X, Y, main="Distance de freinage en fonction de la vitesse du vehicule", ylab="distance en pieds", xlab="vitesse  (miles/h)", col="red", pch=3)
l8=lm(sqrt(Y)~sqrt(X));
abline(l8)
summary(lm(sqrt(Y)~sqrt(X)))$r.squared
plot(X, Y, main="Distance de freinage en fonction de la vitesse du vehicule", ylab="distance en pieds", xlab="vitesse  (miles/h)", col="red", pch=3)
l9=lm(Y^2~X^2);
abline(l3)
summary(lm(Y^2~X^2))$r.squared
#Modele choisis
l2=lm(sqrt(Y)~X);
A=l2$coefficients[2]
B=l2$coefficients[1]
plot(X, Y, main="Distance de freinage en fonction de la vitesse du vehicule", ylab="distance en pieds", xlab="vitesse  (miles/h)", col="red", pch=3)
curve((A*x+B)^2,add=TRUE, col="blue")
?Deseq2
?DEseq2
shiny::runApp('Desktop/RNApp/App')
shiny::runApp('Desktop/RNApp/App')
runApp()
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
shiny::runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
shiny::runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
shiny::runApp('Desktop/RNApp/App')
runApp()
runApp()
runApp('Desktop/RNApp/App')
runApp()
runApp('Desktop/RNApp/App')
runApp()
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
runApp()
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
runApp('Desktop/RNApp/App')
